<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>love</title>
    <link href="favicon.ico" rel="shortcut icon" />
    <style>
      body {
        overflow: hidden;
        margin: 0;
      }
      h1 {
        position: fixed;
        top: 50%;
        left: 0;
        width: 100%;
        text-align: center;
        transform: translateY(-50%);
        font-family: 'Love Ya Like A Sister', cursive;
        font-size: 40px;
        color: #c70012;
        padding: 0 20px;
      }
      h1 span {
        font-size: 20px;
      }
      .love-img {
        background-size: cover;
        background-repeat: no-repeat;
        background-position: center;
      }
    </style>
  </head>
  <body onload="Demo()">
    <h1 id="h1"></h1>
    <canvas></canvas>
    <script src="//cdn.jsdelivr.net/npm/eruda"></script>
<script>
  eruda.init();
</script>
    <script>
      var MAX = 5
      var i = 0
      function Demo() {
        CreateBubble()

        if (++i < MAX) setTimeout(Demo, 1000)
      }

/**
* JavaScript Bubbles
*  By EtherDream 2010
*/
+function () {
  //
  // 浏览器辅助
  //
  var _VER_ = navigator.userAgent;
  var _IE6_ = /IE 6/.test(_VER_);

  var STD = !!window.addEventListener;
  var de = document.documentElement;

  _IE6_ && document.execCommand("BackgroundImageCache", false, true);


  //
  // 常量
  //
  var D = 266;				//泡泡直径
  var K = 0.999;
  let num = 0
  var POW_RATE = 0.0001;		//补偿概率
  var POW_RANGE = 0.8;		//补偿范围(基于诞生速度)

  function SPEED_X () { return 8 + RND() * 4 }
  function SPEED_Y () { return 6 + RND() * 2 }


  var arrBubs = [];
  var iBottom;
  var iRight;


  var SQRT = Math.sqrt;
  var ATAN2 = Math.atan2;
  var SIN = Math.sin;
  var COS = Math.cos;
  var ABS = Math.abs;
  var RND = Math.random;
  var ROUND = Math.round;


  function Timer (call, time) {
    var last = +new Date;
    var delay = 0;

    return setInterval(function () {
      // 时间差累计
      var cur = +new Date;
      delay += (cur - last);
      last = cur;

      // 计算帧数
      if (delay >= time) {
        call();
        delay %= time;
      }
    }, 1);
  }

  Timer(update, 17);

  CreateBubble = function () {
    var bub = new Bubble();

    bub.setX(0);
    bub.setY(0);
    bub.vx = SPEED_X();
    bub.vy = SPEED_Y();

    arrBubs.push(bub);
  };



  function update () {
    var n = arrBubs.length;
    var bub, bub2;
    var i, j;


    updateWall();

    for (i = 0; i < n; i++) {
      bub = arrBubs[i];

      bub.paint();

      bub.vx *= K;
      bub.vy *= K;

      if (RND() < POW_RATE) {
        bub.vx = SPEED_X() * (1 + RND() * POW_RANGE);
        bub.vy = SPEED_Y() * (1 + RND() * POW_RANGE);
      }

      bub.setX(bub.x + bub.vx);
      bub.setY(bub.y + bub.vy);
      checkWalls(bub);
    }

    for (i = 0; i < n - 1; i++) {
      bub = arrBubs[i];

      for (j = i + 1; j < n; j++) {
        bub2 = arrBubs[j];
        checkCollision(bub, bub2);
      }
    }
  }

  function updateWall () {
    iRight = de.clientWidth - D;
    iBottom = de.clientHeight - D;
  }

  function checkWalls (bub) {
    if (bub.x < 0) {
      bub.setX(0);
      bub.vx *= -1;
    }
    else if (bub.x > iRight) {
      bub.setX(iRight);
      bub.vx *= -1;
    }

    if (bub.y < 0) {
      bub.setY(0);
      bub.vy *= -1;
    }
    else if (bub.y > iBottom) {
      bub.setY(iBottom);
      bub.vy *= -1;
    }
  }

  function rotate (x, y, sin, cos, reverse) {
    if (reverse)
      return { x: x * cos + y * sin, y: y * cos - x * sin };
    else
      return { x: x * cos - y * sin, y: y * cos + x * sin };
  }

  function checkCollision (bub0, bub1) {
    var dx = bub1.x - bub0.x;
    var dy = bub1.y - bub0.y;
    var dist = SQRT(dx * dx + dy * dy);

    if (dist < D) {
      // 计算角度和正余弦值
      var angle = ATAN2(dy, dx);
      var sin = SIN(angle);
      var cos = COS(angle);

      // 旋转 bub0 的位置
      var pos0 = { x: 0, y: 0 };

      // 旋转 bub1 的速度
      var pos1 = rotate(dx, dy, sin, cos, true);

      // 旋转 bub0 的速度
      var vel0 = rotate(bub0.vx, bub0.vy, sin, cos, true);

      // 旋转 bub1 的速度
      var vel1 = rotate(bub1.vx, bub1.vy, sin, cos, true);

      // 碰撞的作用力
      var vxTotal = vel0.x - vel1.x;
      vel0.x = vel1.x;
      vel1.x = vxTotal + vel0.x;

      // 更新位置
      var absV = ABS(vel0.x) + ABS(vel1.x);
      var overlap = D - ABS(pos0.x - pos1.x);

      pos0.x += vel0.x / absV * overlap;
      pos1.x += vel1.x / absV * overlap;

      // 将位置旋转回来
      var pos0F = rotate(pos0.x, pos0.y, sin, cos, false);
      var pos1F = rotate(pos1.x, pos1.y, sin, cos, false);

      // 将位置调整为屏幕的实际位置
      bub1.setX(bub0.x + pos1F.x);
      bub1.setY(bub0.y + pos1F.y);
      bub0.setX(bub0.x + pos0F.x);
      bub0.setY(bub0.y + pos0F.y);

      // 将速度旋转回来
      var vel0F = rotate(vel0.x, vel0.y, sin, cos, false);
      var vel1F = rotate(vel1.x, vel1.y, sin, cos, false);

      bub0.vx = vel0F.x;
      bub0.vy = vel0F.y;
      bub1.vx = vel1F.x;
      bub1.vy = vel1F.y;
    }
  }



  var APLHA = 0.8;
  var POW = [1, APLHA, APLHA * APLHA];

  /******************************
   * Class Bubble
   ******************************/
  function Bubble () {
    var kOpa = [], kStp = [];
    var arrFlt = [];
    var oBox = document.body.appendChild(document.createElement("div"));
    // let winWidth = window.innerWidth
    // let win = window.innerWidth
    // console.log(winWidth)
    styBox = oBox.style;
    styBox.position = "absolute";
    styBox.width = D + "px";
    styBox.height = D + "px";
    // oBox.classList.add(`img${num}`)
    for (var i = 0; i < 5; i++) {
      var div = document.createElement("div");
      var sty = div.style;
      sty.position = "absolute";
      sty.width = "266px";
      sty.height = "266px";
      div.classList.add('love-img')

      oBox.appendChild(div);
      if (i == 4) {
        if (_IE6_)
          sty.filter = "progid:DXImageTransform.Microsoft.AlphaImageLoader(src=heart.png)";
        else
          sty.backgroundImage = "url(heart.png)";
        break;
      }
      // 泡泡顶层
      if (i == 0) {
        num++
        if (_IE6_)
          sty.filter = `progid:DXImageTransform.Microsoft.AlphaImageLoader(src=WechatIMG6${num}.jpeg)`;
        else
          sty.backgroundImage = `url(WechatIMG6${num}.jpeg)`;
        // break;
      }
      kOpa[i] = 3 * RND();
      kStp[i] = 0.02 * RND();
      if (i > 0) {
        if (STD) {
        sty.backgroundImage = "url(ch" + i - 1 + ".png)";
        arrFlt[i] = sty;
      } else {
        sty.filter = "alpha progid:DXImageTransform.Microsoft.AlphaImageLoader(src=ch" + i - 1 + ".png)";
        arrFlt[i] = div.filters.alpha;
      }
      }
      
    }

    this.styBox = styBox;
    this.kOpa = kOpa;
    this.kStp = kStp;
    this.arrFlt = arrFlt;
  }

  Bubble.prototype.setX = function (x) {
    this.x = x;
    this.styBox.left = ROUND(x) + "px";
  };

  Bubble.prototype.setY = function (y) {
    this.y = y;
    this.styBox.top = ROUND(y) + "px";
  };

  Bubble.prototype.paint = function () {
    var i, v;

    for (i = 1; i < 4; i++) {
      v = ABS(SIN(this.kOpa[i] += this.kStp[i] * RND()));
      v *= POW[i];

      v = ((v * 1e4) >> 0) / 1e4;
      this.arrFlt[i].opacity = STD ? v : v * 100;
    }
  };

}();
    </script>
  </body>
  <script>
         var MAX = 5
      var i = 0
      var canvas = document.querySelector('canvas'),
        ctx = canvas.getContext('2d')

      var ww, wh

      function onResize() {
        ww = canvas.width = window.innerWidth
        wh = canvas.height = window.innerHeight
      }

      ctx.strokeStyle = 'red'
      ctx.shadowBlur = 25
      ctx.shadowColor = 'hsla(0, 100%, 60%,0.5)'

      var precision = 100
      var hearts = []
      var mouseMoved = false
      function onMove(e) {
        mouseMoved = true
        if (e.type === 'touchmove') {
          hearts.push(new Heart(e.touches[0].clientX, e.touches[0].clientY))
          hearts.push(new Heart(e.touches[0].clientX, e.touches[0].clientY))
        } else {
          hearts.push(new Heart(e.clientX, e.clientY))
          hearts.push(new Heart(e.clientX, e.clientY))
        }
      }

      var Heart = function (x, y) {
        this.x = x || Math.random() * ww
        this.y = y || Math.random() * wh
        this.size = Math.random() * 2 + 1
        this.shadowBlur = Math.random() * 10
        this.speedX = (Math.random() + 0.2 - 0.6) * 8
        this.speedY = (Math.random() + 0.2 - 0.6) * 8
        this.speedSize = Math.random() * 0.05 + 0.01
        this.opacity = 1
        this.vertices = []
        for (var i = 0; i < precision; i++) {
          var step = (i / precision - 0.5) * (Math.PI * 2)
          var vector = {
            x: 15 * Math.pow(Math.sin(step), 3),
            y: -(
              13 * Math.cos(step) -
              5 * Math.cos(2 * step) -
              2 * Math.cos(3 * step) -
              Math.cos(4 * step)
            ),
          }
          this.vertices.push(vector)
        }
      }

      Heart.prototype.draw = function () {
        this.size -= this.speedSize
        this.x += this.speedX
        this.y += this.speedY
        ctx.save()
        ctx.translate(-1000, this.y)
        ctx.scale(this.size, this.size)
        ctx.beginPath()
        for (var i = 0; i < precision; i++) {
          var vector = this.vertices[i]
          ctx.lineTo(vector.x, vector.y)
        }
        ctx.globalAlpha = this.size
        ctx.shadowBlur = Math.round((3 - this.size) * 10)
        ctx.shadowColor = 'hsla(0, 100%, 60%,0.5)'
        ctx.shadowOffsetX = this.x + 1000
        ctx.globalCompositeOperation = 'screen'
        ctx.closePath()
        ctx.fill()
        ctx.restore()
      }

      function render(a) {
        requestAnimationFrame(render)

        hearts.push(new Heart())
        ctx.clearRect(0, 0, ww, wh)
        for (var i = 0; i < hearts.length; i++) {
          hearts[i].draw()
          if (hearts[i].size <= 0) {
            hearts.splice(i, 1)
            i--
          }
        }
      }

      onResize()
      window.addEventListener('mousemove', onMove)
      window.addEventListener('touchmove', onMove)
      window.addEventListener('resize', onResize)
      requestAnimationFrame(render)
      starttime()
      function starttime() {
        time(h1, '2021-11-10') // 在一起的时间
        ptimer = setTimeout(starttime, 1000) // 添加计时器
      }

      function time(obj, futimg) {
        var nowtime = new Date().getTime() // 现在时间转换为时间戳
        var futruetime = new Date(futimg).getTime() // 未来时间转换为时间戳
        var msec = nowtime - futruetime // 毫秒 未来时间-现在时间
        var time = msec / 1000 // 毫秒/1000
        var day = parseInt(time / 86400) // 天  24*60*60*1000
        var hour = parseInt(time / 3600) - 24 * day // 小时 60*60 总小时数-过去的小时数=现在的小时数
        var minute = parseInt((time % 3600) / 60) // 分 -(day*24) 以60秒为一整份 取余 剩下秒数 秒数/60 就是分钟数
        var second = parseInt(time % 60) // 以60秒为一整份 取余 剩下秒数

        obj.innerHTML =
          '亲爱的<br>咱俩在一起的时间已经：<br>' +
          day +
          '天' +
          hour +
          '小时' +
          minute +
          '分' +
          second +
          '秒' +
          '了<br><span>一时间不知道从哪说起,真爱来了，我们要好好把握。<br>不管面临多大的压力,不管前面的路如何崎岖.<br>不管经历过什么,我仍坚信最浪漫的事就是和你一起慢慢变老.<br>相信中间的计时器,将永远继续下去,直至数据溢出.</span>'

        return true
      }
  </script>
</html>
